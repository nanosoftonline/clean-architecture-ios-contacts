//
//  Mocks.generated.swift
//  Contacts
//
//  Generated by Mockingbird v0.20.0.
//  DO NOT EDIT
//

@testable import Contacts
@testable import Mockingbird
import CoreData
import Foundation
import Swift
import SwiftUI
import Swinject

private let mkbGenericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked ContactDataSource
public final class ContactDataSourceMock: Contacts.ContactDataSource, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.ContactDataSource
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ContactDataSourceMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `create`(`data`: Contacts.ContactRequestModel)
  public func `create`(`data`: Contacts.ContactRequestModel) async -> Bool {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`create`(`data`: Contacts.ContactRequestModel) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`data`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Contacts.ContactRequestModel) async -> Bool { return await mkbImpl(`data`) }
      if let mkbImpl = mkbImpl as? () async -> Bool { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = await mkbObject.`create`(data: `data`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `create`(`data`: @autoclosure () -> Contacts.ContactRequestModel) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`create`(`data`: Contacts.ContactRequestModel) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`data`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }

  // MARK: Mocked `delete`(`id`: UUID)
  public func `delete`(`id`: UUID) async -> Bool {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`delete`(`id`: UUID) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID) async -> Bool { return await mkbImpl(`id`) }
      if let mkbImpl = mkbImpl as? () async -> Bool { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = await mkbObject.`delete`(id: `id`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `delete`(`id`: @autoclosure () -> UUID) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`delete`(`id`: UUID) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }

  // MARK: Mocked `update`(`id`: UUID, `data`: Contacts.ContactRequestModel)
  public func `update`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Bool {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`update`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`), Mockingbird.ArgumentMatcher(`data`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID, Contacts.ContactRequestModel) async -> Bool { return await mkbImpl(`id`, `data`) }
      if let mkbImpl = mkbImpl as? () async -> Bool { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = await mkbObject.`update`(id: `id`, data: `data`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `update`(`id`: @autoclosure () -> UUID, `data`: @autoclosure () -> Contacts.ContactRequestModel) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID, Contacts.ContactRequestModel) async -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID, Contacts.ContactRequestModel) async -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`update`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`), Mockingbird.resolve(`data`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }

  // MARK: Mocked `getOne`(`id`: UUID)
  public func `getOne`(`id`: UUID) async -> Contacts.ContactResponseModel? {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getOne`(`id`: UUID) async -> Contacts.ContactResponseModel?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`)], returnType: Swift.ObjectIdentifier((Contacts.ContactResponseModel?).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID) async -> Contacts.ContactResponseModel? { return await mkbImpl(`id`) }
      if let mkbImpl = mkbImpl as? () async -> Contacts.ContactResponseModel? { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Contacts.ContactResponseModel? = await mkbObject.`getOne`(id: `id`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Contacts.ContactResponseModel?).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getOne`(`id`: @autoclosure () -> UUID) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Contacts.ContactResponseModel?, Contacts.ContactResponseModel?> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Contacts.ContactResponseModel?, Contacts.ContactResponseModel?>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getOne`(`id`: UUID) async -> Contacts.ContactResponseModel?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`)], returnType: Swift.ObjectIdentifier((Contacts.ContactResponseModel?).self)))
  }

  // MARK: Mocked `getAll`()
  public func `getAll`() async -> [Contacts.ContactResponseModel] {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getAll`() async -> [Contacts.ContactResponseModel]", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([Contacts.ContactResponseModel]).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> [Contacts.ContactResponseModel] { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [Contacts.ContactResponseModel] = await mkbObject.`getAll`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([Contacts.ContactResponseModel]).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getAll`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> [Contacts.ContactResponseModel], [Contacts.ContactResponseModel]> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> [Contacts.ContactResponseModel], [Contacts.ContactResponseModel]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getAll`() async -> [Contacts.ContactResponseModel]", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([Contacts.ContactResponseModel]).self)))
  }
}

/// Returns a concrete mock of `ContactDataSource`.
public func mock(_ type: Contacts.ContactDataSource.Protocol, file: StaticString = #file, line: UInt = #line) -> ContactDataSourceMock {
  return ContactDataSourceMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ContactListViewModel
public final class ContactListViewModelMock: Contacts.ContactListViewModel, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.ContactListViewModel
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  public enum InitializerProxy {
    public static func initialize(`getAllContacts`: Contacts.GetAllContactsUseCaseProtocol, __file: StaticString = #file, __line: UInt = #line) -> ContactListViewModelMock {
      let mock: ContactListViewModelMock = ContactListViewModelMock(getAllContacts: `getAllContacts`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked contacts
  override public var `contacts`: [Contacts.ContactResponseModel] {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "contacts.getter", setterSelectorName: "contacts.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier(([Contacts.ContactResponseModel]).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> [Contacts.ContactResponseModel] { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as [Contacts.ContactResponseModel] }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`contacts`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: [Contacts.ContactResponseModel] = mkbObject.`contacts`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([Contacts.ContactResponseModel]).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "contacts.setter", setterSelectorName: "contacts.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? ([Contacts.ContactResponseModel]) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`contacts` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`contacts` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getContacts() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [Contacts.ContactResponseModel], [Contacts.ContactResponseModel]> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> [Contacts.ContactResponseModel], [Contacts.ContactResponseModel]>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "contacts.getter", setterSelectorName: "contacts.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier(([Contacts.ContactResponseModel]).self)))
  }

  public func setContacts(_ newValue: @autoclosure () -> [Contacts.ContactResponseModel]) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([Contacts.ContactResponseModel]) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, ([Contacts.ContactResponseModel]) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "contacts.setter", setterSelectorName: "contacts.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked errorMessage
  override public var `errorMessage`: String {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "errorMessage.getter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as String }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`errorMessage`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: String = mkbObject.`errorMessage`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "errorMessage.setter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (String) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`errorMessage` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`errorMessage` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getErrorMessage() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "errorMessage.getter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self)))
  }

  public func setErrorMessage(_ newValue: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (String) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (String) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "errorMessage.setter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked `getContacts`()
  public override func `getContacts`() async -> Void {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getContacts`() async -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> Void { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return await super.`getContacts`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = await mkbObject.`getContacts`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getContacts`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getContacts`() async -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init(`getAllContacts`: Contacts.GetAllContactsUseCaseProtocol)
  public required override init(`getAllContacts`: Contacts.GetAllContactsUseCaseProtocol) {
    super.init(getAllContacts: `getAllContacts`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(`getAllContacts`: Contacts.GetAllContactsUseCaseProtocol)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`getAllContacts`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(`getAllContacts`: @autoclosure () -> Contacts.GetAllContactsUseCaseProtocol) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Contacts.GetAllContactsUseCaseProtocol) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Contacts.GetAllContactsUseCaseProtocol) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(`getAllContacts`: Contacts.GetAllContactsUseCaseProtocol)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`getAllContacts`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(ContactListViewModel.self).initialize(…)`.
public func mock(_ type: Contacts.ContactListViewModel.Type, file: StaticString = #file, line: UInt = #line) -> ContactListViewModelMock.InitializerProxy.Type {
  return ContactListViewModelMock.InitializerProxy.self
}

// MARK: - Mocked ContactNewViewModel
public final class ContactNewViewModelMock: Contacts.ContactNewViewModel, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.ContactNewViewModel
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  public enum InitializerProxy {
    public static func initialize(`createContact`: Contacts.CreateContactUseCaseProtocol, __file: StaticString = #file, __line: UInt = #line) -> ContactNewViewModelMock {
      let mock: ContactNewViewModelMock = ContactNewViewModelMock(createContact: `createContact`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked errorMessage
  override public var `errorMessage`: String {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "errorMessage.getter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as String }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`errorMessage`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: String = mkbObject.`errorMessage`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "errorMessage.setter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (String) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`errorMessage` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`errorMessage` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getErrorMessage() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "errorMessage.getter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self)))
  }

  public func setErrorMessage(_ newValue: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (String) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (String) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "errorMessage.setter", setterSelectorName: "errorMessage.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked name
  override public var `name`: String {
    get {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "name.getter", setterSelectorName: "name.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? () -> String { return mkbImpl() }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as String }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`name`
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: String = mkbObject.`name`
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (String).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
    set {
      return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "name.setter", setterSelectorName: "name.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.ArgumentMatcher(newValue)], returnType: Swift.ObjectIdentifier(Void.self))) {
        self.mockingbirdContext.recordInvocation($0)
        let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
        if let mkbImpl = mkbImpl as? (String) -> Void { return mkbImpl(newValue) }
        if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
        if let mkbImpl = mkbImpl as? (Any?) -> Any { return Mockingbird.dynamicCast(mkbImpl(newValue as Any?)) as Void }
        if let mkbImpl = mkbImpl as? () -> Any { return Mockingbird.dynamicCast(mkbImpl()) as Void }
        for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
          switch mkbTargetBox.target {
          case .super:
            return super.`name` = newValue
          case .object(let mkbObject):
            guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
            let mkbValue: Void = mkbObject.`name` = newValue
            self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
            return mkbValue
          }
        }
        if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
        self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
      }
    }
  }

  public func getName() -> Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String> {
    return Mockingbird.Mockable<Mockingbird.PropertyGetterDeclaration, () -> String, String>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "name.getter", setterSelectorName: "name.setter", selectorType: Mockingbird.SelectorType.getter, arguments: [], returnType: Swift.ObjectIdentifier((String).self)))
  }

  public func setName(_ newValue: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (String) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.PropertySetterDeclaration, (String) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "name.setter", setterSelectorName: "name.setter", selectorType: Mockingbird.SelectorType.setter, arguments: [Mockingbird.resolve(newValue)], returnType: Swift.ObjectIdentifier(Void.self)))
  }

  // MARK: Mocked `createContact`()
  public override func `createContact`() async -> Void {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`createContact`() async -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> Void { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return await super.`createContact`()
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = await mkbObject.`createContact`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `createContact`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`createContact`() async -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked init(`createContact`: Contacts.CreateContactUseCaseProtocol)
  public required override init(`createContact`: Contacts.CreateContactUseCaseProtocol) {
    super.init(createContact: `createContact`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(`createContact`: Contacts.CreateContactUseCaseProtocol)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`createContact`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(`createContact`: @autoclosure () -> Contacts.CreateContactUseCaseProtocol) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Contacts.CreateContactUseCaseProtocol) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Contacts.CreateContactUseCaseProtocol) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(`createContact`: Contacts.CreateContactUseCaseProtocol)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`createContact`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `onNameChange`(`name`: String)
  public override func `onNameChange`(`name`: String) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`onNameChange`(`name`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`name`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (String) -> Void { return mkbImpl(`name`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return super.`onNameChange`(name: `name`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`onNameChange`(name: `name`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `onNameChange`(`name`: @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (String) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`onNameChange`(`name`: String) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`name`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(ContactNewViewModel.self).initialize(…)`.
public func mock(_ type: Contacts.ContactNewViewModel.Type, file: StaticString = #file, line: UInt = #line) -> ContactNewViewModelMock.InitializerProxy.Type {
  return ContactNewViewModelMock.InitializerProxy.self
}

// MARK: - Mocked ContactRepository
public final class ContactRepositoryMock: Contacts.ContactRepository, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.ContactRepository
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ContactRepositoryMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getContact`(`id`: UUID)
  public func `getContact`(`id`: UUID) async -> Result<Contacts.ContactResponseModel?, Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getContact`(`id`: UUID) async -> Result<Contacts.ContactResponseModel?, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`)], returnType: Swift.ObjectIdentifier((Result<Contacts.ContactResponseModel?, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID) async -> Result<Contacts.ContactResponseModel?, Error> { return await mkbImpl(`id`) }
      if let mkbImpl = mkbImpl as? () async -> Result<Contacts.ContactResponseModel?, Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<Contacts.ContactResponseModel?, Error> = await mkbObject.`getContact`(id: `id`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<Contacts.ContactResponseModel?, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getContact`(`id`: @autoclosure () -> UUID) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Result<Contacts.ContactResponseModel?, Error>, Result<Contacts.ContactResponseModel?, Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Result<Contacts.ContactResponseModel?, Error>, Result<Contacts.ContactResponseModel?, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getContact`(`id`: UUID) async -> Result<Contacts.ContactResponseModel?, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`)], returnType: Swift.ObjectIdentifier((Result<Contacts.ContactResponseModel?, Error>).self)))
  }

  // MARK: Mocked `createContact`(`data`: Contacts.ContactRequestModel)
  public func `createContact`(`data`: Contacts.ContactRequestModel) async -> Result<Void, Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`createContact`(`data`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`data`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Contacts.ContactRequestModel) async -> Result<Void, Error> { return await mkbImpl(`data`) }
      if let mkbImpl = mkbImpl as? () async -> Result<Void, Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<Void, Error> = await mkbObject.`createContact`(data: `data`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<Void, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `createContact`(`data`: @autoclosure () -> Contacts.ContactRequestModel) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`createContact`(`data`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`data`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self)))
  }

  // MARK: Mocked `deleteContact`(`id`: UUID)
  public func `deleteContact`(`id`: UUID) async -> Result<Void, Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`deleteContact`(`id`: UUID) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID) async -> Result<Void, Error> { return await mkbImpl(`id`) }
      if let mkbImpl = mkbImpl as? () async -> Result<Void, Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<Void, Error> = await mkbObject.`deleteContact`(id: `id`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<Void, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `deleteContact`(`id`: @autoclosure () -> UUID) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Result<Void, Error>, Result<Void, Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Result<Void, Error>, Result<Void, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`deleteContact`(`id`: UUID) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self)))
  }

  // MARK: Mocked `updateContact`(`id`: UUID, `data`: Contacts.ContactRequestModel)
  public func `updateContact`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Result<Void, Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`updateContact`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`), Mockingbird.ArgumentMatcher(`data`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID, Contacts.ContactRequestModel) async -> Result<Void, Error> { return await mkbImpl(`id`, `data`) }
      if let mkbImpl = mkbImpl as? () async -> Result<Void, Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<Void, Error> = await mkbObject.`updateContact`(id: `id`, data: `data`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<Void, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `updateContact`(`id`: @autoclosure () -> UUID, `data`: @autoclosure () -> Contacts.ContactRequestModel) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID, Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID, Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`updateContact`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`), Mockingbird.resolve(`data`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self)))
  }

  // MARK: Mocked `getContacts`()
  public func `getContacts`() async -> Result<[Contacts.ContactResponseModel], Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getContacts`() async -> Result<[Contacts.ContactResponseModel], Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Result<[Contacts.ContactResponseModel], Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> Result<[Contacts.ContactResponseModel], Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<[Contacts.ContactResponseModel], Error> = await mkbObject.`getContacts`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<[Contacts.ContactResponseModel], Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getContacts`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Result<[Contacts.ContactResponseModel], Error>, Result<[Contacts.ContactResponseModel], Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Result<[Contacts.ContactResponseModel], Error>, Result<[Contacts.ContactResponseModel], Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`getContacts`() async -> Result<[Contacts.ContactResponseModel], Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Result<[Contacts.ContactResponseModel], Error>).self)))
  }
}

/// Returns a concrete mock of `ContactRepository`.
public func mock(_ type: Contacts.ContactRepository.Protocol, file: StaticString = #file, line: UInt = #line) -> ContactRepositoryMock {
  return ContactRepositoryMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CreateContactUseCaseProtocol
public final class CreateContactUseCaseProtocolMock: Contacts.CreateContactUseCaseProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.CreateContactUseCaseProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    CreateContactUseCaseProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `execute`(`contact`: Contacts.ContactRequestModel)
  public func `execute`(`contact`: Contacts.ContactRequestModel) async -> Result<Void, Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`execute`(`contact`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`contact`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Contacts.ContactRequestModel) async -> Result<Void, Error> { return await mkbImpl(`contact`) }
      if let mkbImpl = mkbImpl as? () async -> Result<Void, Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<Void, Error> = await mkbObject.`execute`(contact: `contact`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<Void, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `execute`(`contact`: @autoclosure () -> Contacts.ContactRequestModel) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`execute`(`contact`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`contact`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self)))
  }
}

/// Returns a concrete mock of `CreateContactUseCaseProtocol`.
public func mock(_ type: Contacts.CreateContactUseCaseProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> CreateContactUseCaseProtocolMock {
  return CreateContactUseCaseProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked CreateContact
public final class CreateContactMock: Contacts.CreateContact, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.CreateContact
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  public enum InitializerProxy {
    public static func initialize(`contactRepo`: Contacts.ContactRepository?, __file: StaticString = #file, __line: UInt = #line) -> CreateContactMock {
      let mock: CreateContactMock = CreateContactMock(contactRepo: `contactRepo`)
      mock.mockingbirdContext.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `execute`(`contact`: Contacts.ContactRequestModel)
  public override func `execute`(`contact`: Contacts.ContactRequestModel) async -> Result<Void, Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`execute`(`contact`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`contact`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Contacts.ContactRequestModel) async -> Result<Void, Error> { return await mkbImpl(`contact`) }
      if let mkbImpl = mkbImpl as? () async -> Result<Void, Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          return await super.`execute`(contact: `contact`)
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<Void, Error> = await mkbObject.`execute`(contact: `contact`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<Void, Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `execute`(`contact`: @autoclosure () -> Contacts.ContactRequestModel) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (Contacts.ContactRequestModel) async -> Result<Void, Error>, Result<Void, Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`execute`(`contact`: Contacts.ContactRequestModel) async -> Result<Void, Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`contact`)], returnType: Swift.ObjectIdentifier((Result<Void, Error>).self)))
  }

  // MARK: Mocked init(`contactRepo`: Contacts.ContactRepository?)
  public required override init(`contactRepo`: Contacts.ContactRepository?) {
    super.init(contactRepo: `contactRepo`)
    self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "init(`contactRepo`: Contacts.ContactRepository?)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`contactRepo`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  public func initialize(`contactRepo`: @autoclosure () -> Contacts.ContactRepository?) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Contacts.ContactRepository?) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Contacts.ContactRepository?) -> Void, Void>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "init(`contactRepo`: Contacts.ContactRepository?)", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`contactRepo`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }
}

/// Returns an abstract mock which should be initialized using `mock(CreateContact.self).initialize(…)`.
public func mock(_ type: Contacts.CreateContact.Type, file: StaticString = #file, line: UInt = #line) -> CreateContactMock.InitializerProxy.Type {
  return CreateContactMock.InitializerProxy.self
}

// MARK: - Mocked DeleteCustomer
public final class DeleteCustomerMock: Contacts.DeleteCustomer, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.DeleteCustomer
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    DeleteCustomerMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `execute`(`id`: UUID)
  public func `execute`(`id`: UUID) async -> Bool {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`execute`(`id`: UUID) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID) async -> Bool { return await mkbImpl(`id`) }
      if let mkbImpl = mkbImpl as? () async -> Bool { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = await mkbObject.`execute`(id: `id`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `execute`(`id`: @autoclosure () -> UUID) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`execute`(`id`: UUID) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }
}

/// Returns a concrete mock of `DeleteCustomer`.
public func mock(_ type: Contacts.DeleteCustomer.Protocol, file: StaticString = #file, line: UInt = #line) -> DeleteCustomerMock {
  return DeleteCustomerMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked GetAllContactsUseCaseProtocol
public final class GetAllContactsUseCaseProtocolMock: Contacts.GetAllContactsUseCaseProtocol, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.GetAllContactsUseCaseProtocol
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    GetAllContactsUseCaseProtocolMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `execute`()
  public func `execute`() async -> Result<[Contacts.ContactResponseModel], Error> {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`execute`() async -> Result<[Contacts.ContactResponseModel], Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Result<[Contacts.ContactResponseModel], Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () async -> Result<[Contacts.ContactResponseModel], Error> { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Result<[Contacts.ContactResponseModel], Error> = await mkbObject.`execute`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Result<[Contacts.ContactResponseModel], Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `execute`() async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Result<[Contacts.ContactResponseModel], Error>, Result<[Contacts.ContactResponseModel], Error>> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, () async -> Result<[Contacts.ContactResponseModel], Error>, Result<[Contacts.ContactResponseModel], Error>>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`execute`() async -> Result<[Contacts.ContactResponseModel], Error>", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Result<[Contacts.ContactResponseModel], Error>).self)))
  }
}

/// Returns a concrete mock of `GetAllContactsUseCaseProtocol`.
public func mock(_ type: Contacts.GetAllContactsUseCaseProtocol.Protocol, file: StaticString = #file, line: UInt = #line) -> GetAllContactsUseCaseProtocolMock {
  return GetAllContactsUseCaseProtocolMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked GetContact
public final class GetContactMock: Contacts.GetContact, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.GetContact
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    GetContactMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `execute`(`id`: UUID)
  public func `execute`(`id`: UUID) async -> Contacts.ContactResponseModel? {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`execute`(`id`: UUID) async -> Contacts.ContactResponseModel?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`)], returnType: Swift.ObjectIdentifier((Contacts.ContactResponseModel?).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID) async -> Contacts.ContactResponseModel? { return await mkbImpl(`id`) }
      if let mkbImpl = mkbImpl as? () async -> Contacts.ContactResponseModel? { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Contacts.ContactResponseModel? = await mkbObject.`execute`(id: `id`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Contacts.ContactResponseModel?).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `execute`(`id`: @autoclosure () -> UUID) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Contacts.ContactResponseModel?, Contacts.ContactResponseModel?> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID) async -> Contacts.ContactResponseModel?, Contacts.ContactResponseModel?>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`execute`(`id`: UUID) async -> Contacts.ContactResponseModel?", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`)], returnType: Swift.ObjectIdentifier((Contacts.ContactResponseModel?).self)))
  }
}

/// Returns a concrete mock of `GetContact`.
public func mock(_ type: Contacts.GetContact.Protocol, file: StaticString = #file, line: UInt = #line) -> GetContactMock {
  return GetContactMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked UpdateContact
public final class UpdateContactMock: Contacts.UpdateContact, Mockingbird.Mock {
  typealias MockingbirdSupertype = Contacts.UpdateContact
  public static let mockingbirdContext = Mockingbird.Context()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.20.0", "module_name": "Contacts"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    UpdateContactMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `execute`(`id`: UUID, `data`: Contacts.ContactRequestModel)
  public func `execute`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Bool {
    return await self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`execute`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`id`), Mockingbird.ArgumentMatcher(`data`)], returnType: Swift.ObjectIdentifier((Bool).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (UUID, Contacts.ContactRequestModel) async -> Bool { return await mkbImpl(`id`, `data`) }
      if let mkbImpl = mkbImpl as? () async -> Bool { return await mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Bool = await mkbObject.`execute`(id: `id`, data: `data`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Bool).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `execute`(`id`: @autoclosure () -> UUID, `data`: @autoclosure () -> Contacts.ContactRequestModel) async -> Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID, Contacts.ContactRequestModel) async -> Bool, Bool> {
    return Mockingbird.Mockable<Mockingbird.AsyncFunctionDeclaration, (UUID, Contacts.ContactRequestModel) async -> Bool, Bool>(context: self.mockingbirdContext, invocation: Mockingbird.SwiftInvocation(selectorName: "`execute`(`id`: UUID, `data`: Contacts.ContactRequestModel) async -> Bool", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`id`), Mockingbird.resolve(`data`)], returnType: Swift.ObjectIdentifier((Bool).self)))
  }
}

/// Returns a concrete mock of `UpdateContact`.
public func mock(_ type: Contacts.UpdateContact.Protocol, file: StaticString = #file, line: UInt = #line) -> UpdateContactMock {
  return UpdateContactMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
